// node_modules/olova/dist/olova.js
var e = Symbol("BATCH_UPDATES");
var t = Symbol("SIGNAL_TYPE");
var n = class {
  constructor() {
    this.globalSubs = /* @__PURE__ */ new Set(), this.propSubs = /* @__PURE__ */ new Map(), this.weakPropSubs = /* @__PURE__ */ new WeakMap(), this.dependencies = /* @__PURE__ */ new WeakMap(), this.batchMode = false, this.pendingDeps = /* @__PURE__ */ new Set();
  }
  subscribe(e2, t2) {
    if (!t2) return;
    this.dependencies.has(t2) || this.dependencies.set(t2, /* @__PURE__ */ new Set());
    const n2 = this.dependencies.get(t2);
    if (!n2.has(e2)) {
      if (n2.add(e2), !e2) return void this.globalSubs.add(t2);
      const r2 = "object" == typeof e2 ? this.weakPropSubs : this.propSubs;
      r2.has(e2) || r2.set(e2, /* @__PURE__ */ new Set()), r2.get(e2).add(t2);
    }
  }
  notify(e2, t2 = /* @__PURE__ */ new Set()) {
    if (this.batchMode) return this.pendingDeps.add(e2), t2;
    if (e2) {
      const n2 = this.propSubs.get(e2);
      if (n2 && this.notifyDependentSubs(n2, e2, t2), "object" == typeof e2) {
        const n3 = this.weakPropSubs.get(e2);
        n3 && this.notifyDependentSubs(n3, e2, t2);
      }
    }
    return this.notifyDependentSubs(this.globalSubs, e2, t2), t2;
  }
  startBatch() {
    this.batchMode = true, this.pendingDeps.clear();
  }
  endBatch() {
    this.batchMode = false;
    const e2 = /* @__PURE__ */ new Set();
    for (const t2 of this.pendingDeps) this.notify(t2, e2);
    return this.pendingDeps.clear(), e2;
  }
  notifyDependentSubs(e2, t2, n2) {
    for (const r2 of e2) if (!n2.has(r2)) {
      const e3 = this.dependencies.get(r2);
      t2 && e3 && !e3.has(t2) || (r2(), n2.add(r2));
    }
  }
  cleanup(e2) {
    if (e2) {
      this.propSubs.delete(e2);
      for (const [t2, n2] of this.dependencies) n2.delete(e2), 0 === n2.size && this.dependencies.delete(t2);
    }
  }
};
var r = class {
  constructor() {
    this.updates = /* @__PURE__ */ new Map(), this.priorities = /* @__PURE__ */ new Map(), this.timeouts = /* @__PURE__ */ new Map(), this.debounceTime = 16;
  }
  add(e2, t2, n2 = 0, r2 = false) {
    if (r2) return this.timeouts.has(e2) && clearTimeout(this.timeouts.get(e2)), void this.timeouts.set(e2, setTimeout(() => {
      this.addImmediate(e2, t2, n2), this.timeouts.delete(e2);
    }, this.debounceTime));
    this.addImmediate(e2, t2, n2);
  }
  addImmediate(e2, t2, n2) {
    if (this.updates.has(e2)) {
      const r2 = this.updates.get(e2), o2 = this.priorities.get(e2) || 0;
      "object" == typeof r2 && "object" == typeof t2 && (t2 = { ...r2, ...t2 }), n2 = Math.max(o2, n2);
    }
    this.updates.set(e2, t2), this.priorities.set(e2, n2);
  }
  process(e2) {
    0 !== this.updates.size && (this.timeouts.size > 0 ? Promise.all(Array.from(this.timeouts.values()).map((e3) => new Promise((t2) => {
      const n2 = setInterval(() => {
        this.timeouts.has(e3) || (clearInterval(n2), t2());
      }, 0);
    }))).then(() => this.processImmediate(e2)) : this.processImmediate(e2));
  }
  processImmediate(e2) {
    const t2 = [...this.updates.entries()].sort((e3, t3) => (this.priorities.get(t3[0]) || 0) - (this.priorities.get(e3[0]) || 0));
    e2.startBatch();
    const n2 = /* @__PURE__ */ new Set();
    for (const [r2, o2] of t2) "function" == typeof o2 && o2(), e2.notify(r2, n2);
    e2.endBatch(), this.updates.clear(), this.priorities.clear();
  }
  clear() {
    this.timeouts.forEach((e2) => clearTimeout(e2)), this.timeouts.clear(), this.updates.clear(), this.priorities.clear();
  }
};
var o = (o2, i2 = {}) => {
  const { equals: s2 = Object.is, immediate: a2 = true, batched: c2 = false, debounce: l2 = false, throttle: u2 = 0, persistence: d2 = false, validate: f2, transform: h2, history: m2 = 0, middleware: g2 = [], onError: y2, computed: b2 } = i2;
  let w2 = o2;
  const S2 = new n(), x2 = new r(), T2 = m2 > 0 ? new Array(m2) : null;
  let E2 = -1;
  const C = { readCount: 0, writeCount: 0, lastUpdateTime: 0, averageUpdateTime: 0, totalUpdateTime: 0 }, v = /* @__PURE__ */ new Map();
  let N = true;
  const M = d2 && "string" == typeof d2 ? d2 : `signal_${Math.random().toString(36).slice(2)}`;
  if (d2) try {
    const e2 = localStorage.getItem(M);
    e2 && (w2 = JSON.parse(e2));
  } catch (e2) {
    A(e2, "persistence_load");
  }
  const A = (e2, t2, n2 = {}) => {
    const r2 = { error: e2, phase: t2, value: w2, timestamp: Date.now(), ...n2 };
    y2 ? y2(r2) : console.error("Signal error:", r2);
  }, _ = (e2) => {
    C.readCount++;
    const t2 = p();
    return t2 && S2.subscribe(e2, t2), b2 && e2 && b2[e2] ? (!N && v.has(e2) || v.set(e2, b2[e2](w2)), v.get(e2)) : e2 ? w2[e2] : w2;
  }, D = { undo: () => {
    !T2 || E2 < 0 || (w2 = structuredClone(T2[E2]), E2 = (E2 - 1 + m2) % m2, S2.notify());
  }, reset: () => {
    w2 = o2, T2 && T2.fill(void 0), E2 = -1, v.clear(), N = true, S2.notify();
  }, getMetrics: () => ({ ...C }), getHistory: () => T2 ? [...T2] : null, subscribe: (e2) => S2.subscribe(null, e2), batch: _[e] };
  return Object.assign(_, D), _[t] = true, _[e] = () => (S2.startBatch(), () => {
    S2.endBatch(), x2.clear();
  }), [_, async (e2, t2, n2 = 0) => {
    const r2 = performance.now();
    C.writeCount++;
    try {
      let o3 = e2;
      for (const e3 of g2) o3 = await e3(o3, { prop: t2, value: w2, options: i2 });
      const a3 = ((e3) => {
        if (!h2) return e3;
        try {
          return h2(e3);
        } catch (t3) {
          return A(t3, "transform"), e3;
        }
      })("function" == typeof o3 ? o3(t2 ? w2[t2] : w2) : o3);
      if (!((e3) => {
        if (!f2) return true;
        try {
          return f2(e3);
        } catch (e4) {
          return A(e4, "validation"), false;
        }
      })(a3)) return void A(new Error("Validation failed"), "validation", { newValue: a3 });
      if (!(t2 ? !s2(w2[t2], a3) : !s2(w2, a3))) return;
      if (T2 && (E2 = (E2 + 1) % m2, T2[E2] = structuredClone(w2)), w2 = t2 ? { ...w2, [t2]: a3 } : a3, N = true, v.clear(), d2) try {
        localStorage.setItem(M, JSON.stringify(w2));
      } catch (e3) {
        A(e3, "persistence_save");
      }
      c2 ? (x2.add(t2, a3, n2, l2), queueMicrotask(() => {
        x2.process(S2);
      })) : S2.notify(t2);
      const u3 = performance.now() - r2;
      C.lastUpdateTime = u3, C.totalUpdateTime += u3, C.averageUpdateTime = C.totalUpdateTime / C.writeCount;
    } catch (e3) {
      A(e3, "write");
    }
  }];
};
function i(e2, t2 = [], n2 = {}) {
  const { immediate: r2 = true, batch: o2 = true, debounce: i2 = 0, throttle: s2 = 0, priority: a2 = 0, errorHandler: c2 } = n2;
  let l2 = null, u2 = /* @__PURE__ */ new Set(), d2 = [], f2 = false, p2 = 0, m2 = null, g2 = 0, y2 = 0;
  const b2 = { totalExecutionTime: 0, averageExecutionTime: 0, lastExecutionTime: 0, maxExecutionTime: 0 }, w2 = () => {
    try {
      l2 && l2(), u2.forEach((e3) => {
        try {
          e3();
        } catch (e4) {
          S2(e4, "cleanup function");
        }
      }), u2.clear();
    } catch (e3) {
      S2(e3, "main cleanup");
    }
  }, S2 = (e3, n3, r3 = 0) => {
    y2++;
    const o3 = { error: e3, phase: n3, executionCount: g2, dependencies: [...t2], timestamp: Date.now() };
    c2 ? c2(o3) : console.error("Effect error:", o3), r3 < 3 && setTimeout(() => {
      x2(r3 + 1);
    }, 1e3 * Math.pow(2, r3));
  }, x2 = async (n3 = 0) => {
    if (f2 && s2 > 0) return;
    if (!r2 && d2.length === t2.length && !t2.some((e3, t3) => {
      const n4 = d2[t3];
      return !Object.is(e3, n4) && JSON.stringify(e3) !== JSON.stringify(n4);
    })) return;
    const o3 = performance.now();
    f2 = true;
    try {
      w2(), h = x2;
      const n4 = await Promise.resolve(e2());
      l2 = n4 || null;
      const r3 = performance.now() - o3;
      b2.totalExecutionTime += r3, b2.lastExecutionTime = r3, b2.maxExecutionTime = Math.max(b2.maxExecutionTime, r3), b2.averageExecutionTime = b2.totalExecutionTime / ++g2, r3 > 16 && console.warn(`Long running effect detected (${r3.toFixed(2)}ms)`), d2 = [...t2], p2 = Date.now(), y2 = 0;
    } catch (e3) {
      S2(e3, "execution", n3);
    } finally {
      h = null, f2 = false;
    }
  }, T2 = () => {
    clearTimeout(m2), m2 = setTimeout(x2, i2);
  }, E2 = { execute: () => i2 > 0 ? T2() : x2(), cleanup: w2, isRunning: () => f2, getMetrics: () => ({ ...b2 }), registerCleanup: (e3) => {
    if ("function" != typeof e3) throw new Error("Cleanup must be a function");
    return u2.add(e3), () => u2.delete(e3);
  }, reset: () => {
    w2(), d2 = [], g2 = 0, y2 = 0, Object.keys(b2).forEach((e3) => b2[e3] = 0);
  } };
  return r2 && (o2 ? queueMicrotask(() => {
    i2 > 0 ? T2() : x2();
  }) : i2 > 0 ? T2() : x2()), E2;
}
function s(e2) {
  const t2 = p();
  if (!t2) throw new Error("onCleanup must be called within a reactive context");
  if (!t2.cleanupFns) return e2;
  t2.cleanupFns.add(e2);
}
function a(e2, t2 = [], n2 = {}) {
  const [r2, s2] = o(void 0, n2);
  let a2 = false, c2 = [];
  return i(() => {
    if (c2.length > 0 && t2.length > 0 && !t2.some((e3, t3) => e3 !== c2[t3])) return;
    const o2 = e2();
    a2 && n2.equals && n2.equals(r2(), o2) || (s2(o2), a2 = true), c2 = [...t2];
  }, t2), r2;
}
function c(e2, t2 = {}) {
  const { initialValue: n2 = null, cacheTime: r2 = 5e3, retries: i2 = 3, retryDelay: s2 = 1e3, lazy: a2 = false } = t2, [c2, l2] = o(n2), [u2, d2] = o(false), [f2, h2] = o(null);
  let p2 = /* @__PURE__ */ new Map(), m2 = /* @__PURE__ */ new Map(), g2 = 0;
  const y2 = (e3) => {
    e3 ? (p2.delete(e3), m2.has(e3) && (clearTimeout(m2.get(e3)), m2.delete(e3))) : (p2.clear(), m2.forEach((e4) => clearTimeout(e4)), m2.clear());
  }, b2 = async (t3) => {
    const n3 = JSON.stringify(t3);
    if (p2.has(n3)) return p2.get(n3);
    d2(true), h2(null), g2 = 0;
    const o2 = async () => {
      try {
        const o3 = await e2(t3);
        return l2(o3), p2.set(n3, o3), r2 > 0 && m2.set(n3, setTimeout(() => y2(n3), r2)), o3;
      } catch (e3) {
        if (g2 < i2) return g2++, await new Promise((e4) => setTimeout(e4, s2 * g2)), o2();
        throw h2(e3), e3;
      } finally {
        d2(false);
      }
    };
    return o2();
  };
  return a2 || b2(), { data: c2, loading: u2, error: f2, refetch: b2, clearCache: y2 };
}
function l(e2, n2, ...r2) {
  var _a;
  const o2 = "http://www.w3.org/1999/xhtml", s2 = /* @__PURE__ */ new Set(["svg", "path", "circle", "rect", "line", "polygon", "polyline", "ellipse", "g", "text", "tspan", "defs", "use", "mask", "clipPath", "pattern", "filter", "linearGradient", "radialGradient", "stop", "animate", "animateTransform", "animateMotion", "mpath", "set", "desc", "metadata", "title", "foreignObject", "switch", "symbol", "marker", "view", "image"]), c2 = /* @__PURE__ */ new Set(["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "formnovalidate", "hidden", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected"]);
  if ("function" == typeof e2) return e2[t] ? a(() => e2({ ...n2, children: 1 === r2.length ? r2[0] : r2 }), n2.deps || Object.values(n2)) : e2({ ...n2, children: 1 === r2.length ? r2[0] : r2 });
  if (e2 === u) {
    const e3 = document.createDocumentFragment();
    return r2.flat(1 / 0).forEach((t2) => {
      const n3 = S(t2);
      n3 && e3.appendChild(n3);
    }), e3;
  }
  if ("string" != typeof e2) throw new Error(`Invalid element type: ${e2}`);
  let l2 = o2;
  s2.has(e2.toLowerCase()) ? l2 = "http://www.w3.org/2000/svg" : e2.startsWith("math") && (l2 = "http://www.w3.org/1998/Math/MathML");
  const d2 = l2 !== o2 ? document.createElementNS(l2, e2) : document.createElement(e2);
  if (d2._props = n2, n2) {
    for (const [e3, s3] of Object.entries(n2)) if (null != s3) {
      switch (e3) {
        case "ref":
          "function" == typeof s3 ? (s3(d2), d2._cleanup = () => s3(null)) : s3 && (s3.current = d2, d2._cleanup = () => s3.current = null);
          continue;
        case "dangerouslySetInnerHTML":
          null != s3.__html && (d2.innerHTML = s3.__html, r2 = []);
          continue;
        case "style":
          "string" == typeof s3 ? d2.style.cssText = s3 : Object.entries(s3).forEach(([e4, t2]) => {
            "number" != typeof t2 || /^(z|opacity|flex|order|grid)/.test(e4) || (t2 += "px"), d2.style[e4] = t2;
          });
          continue;
        case "classList":
          Array.isArray(s3) ? d2.classList.add(...s3.filter(Boolean)) : "object" == typeof s3 && Object.entries(s3).forEach(([e4, t2]) => {
            d2.classList.toggle(e4, Boolean(t2));
          });
          continue;
        case "className":
        case "class":
          d2.setAttribute("class", s3);
          continue;
        case "key":
        case "children":
        case "deps":
          continue;
      }
      if (e3.startsWith("on")) {
        const t2 = e3.slice(2).toLowerCase(), n3 = t2.endsWith("capture"), r3 = n3 ? t2.slice(0, -7) : t2, o3 = "function" == typeof s3 ? s3 : new Function(s3);
        d2.addEventListener(r3, o3, n3), d2._cleanupFns || (d2._cleanupFns = /* @__PURE__ */ new Map()), d2._cleanupFns.set(r3, () => {
          d2.removeEventListener(r3, o3, n3);
        });
      } else if ("function" == typeof s3 && s3[t]) {
        const t2 = i(() => {
          l2 !== o2 ? null == s3() || false === s3() ? d2.removeAttribute(e3) : d2.setAttribute(e3, true === s3() ? "" : s3()) : c2.has(e3) ? d2[e3] = Boolean(s3()) : d2[e3] = s3();
        });
        d2._cleanupFns || (d2._cleanupFns = /* @__PURE__ */ new Map()), d2._cleanupFns.set(`${e3}_effect`, t2);
      } else if (l2 !== o2) true === s3 ? d2.setAttribute(e3, "") : false !== s3 && d2.setAttribute(e3, s3);
      else if (c2.has(e3)) d2[e3] = Boolean(s3);
      else try {
        d2[e3] = s3;
      } catch {
        d2.setAttribute(e3, s3);
      }
    }
  }
  const f2 = (e3) => {
    if (null == e3) return;
    if (Array.isArray(e3)) return void e3.flat(1 / 0).forEach(f2);
    const t2 = S(e3);
    t2 && (t2 instanceof DocumentFragment || t2 instanceof Node ? d2.appendChild(t2) : d2.appendChild(document.createTextNode(String(t2))));
  };
  if (r2.forEach(f2), (_a = d2._cleanupFns) == null ? void 0 : _a.size) {
    const e3 = () => {
      d2._cleanupFns.forEach((e4) => e4()), d2._cleanupFns.clear();
    };
    d2._cleanup = e3;
  }
  return d2;
}
var u = Symbol("Fragment");
function d(t2, n2, r2 = {}) {
  const { hydrate: i2 = false, onError: s2 = console.error, suspense: a2 = true, beforeMount: c2, afterMount: l2 } = r2;
  if (!i2) for (; n2.firstChild; ) n2.removeChild(n2.firstChild);
  const [u2] = o(null), d2 = u2[e]();
  let h2 = null;
  function p2(e2, t3, n3, r3 = {}) {
    if (t3) {
      for (; e2.firstChild; ) e2.removeChild(e2.firstChild);
      f(n3, e2, r3.hydrate);
    } else f(n3, e2, r3.hydrate);
  }
  function m2() {
    try {
      let e2 = t2();
      a2 && e2 instanceof Promise ? e2.then((e3) => {
        p2(n2, h2, e3, { hydrate: i2 }), h2 = e3, l2 == null ? void 0 : l2();
      }).catch(s2) : (p2(n2, h2, e2, { hydrate: i2 }), h2 = e2, l2 == null ? void 0 : l2());
    } catch (e2) {
      s2(e2);
    }
  }
  return c2 == null ? void 0 : c2(), m2(), d2(), { update: m2, cleanup: () => {
    for (; n2.firstChild; ) n2.removeChild(n2.firstChild);
  } };
}
function f(e2, t2, n2) {
  if (!e2) return;
  const r2 = Array.isArray(e2) ? e2.flat(1 / 0) : [e2], o2 = Array.from(t2.childNodes);
  let i2 = 0;
  if (r2.filter(Boolean).forEach((e3) => {
    var _a;
    "string" == typeof e3 || "number" == typeof e3 ? n2 && ((_a = o2[i2]) == null ? void 0 : _a.nodeType) === Node.TEXT_NODE ? o2[i2].textContent = String(e3) : t2.appendChild(document.createTextNode(String(e3))) : e3 instanceof Node ? n2 && o2[i2] ? e3.isEqualNode(o2[i2]) || t2.replaceChild(e3, o2[i2]) : t2.appendChild(e3) : Array.isArray(e3) ? f(e3, t2, n2) : e3 && "object" == typeof e3 && t2.appendChild(document.createTextNode(JSON.stringify(e3))), i2++;
  }), !n2) for (; i2 < o2.length; ) t2.removeChild(o2[i2]), i2++;
}
var h = null;
var p = () => h;
function m(e2) {
  const t2 = Symbol("context");
  /* @__PURE__ */ new Map();
  return { Provider: ({ value: e3, children: n2 }) => {
    const r2 = g(t2);
    h = e3;
    return h = r2, n2;
  }, Context: t2, defaultValue: e2 };
}
function g(e2) {
  return h || e2.defaultValue;
}
function y({ fallback: e2, children: t2 }) {
  try {
    return t2;
  } catch (t3) {
    return e2(t3);
  }
}
function b(e2) {
  let t2 = null, n2 = null;
  return function(r2) {
    if (!t2) throw n2 || (n2 = e2().then((e3) => {
      t2 = e3.default || e3;
    })), n2;
    return l(t2, r2);
  };
}
function w(e2 = null) {
  return { current: e2 };
}
"undefined" != typeof window ? (window.h = l, window.Fragment = u) : "undefined" != typeof global && (global.h = l, global.Fragment = u);
var olova_default = { h: l, Fragment: u };
var S = (e2) => {
  if (null == e2 || false === e2 || true === e2) return null;
  const n2 = () => {
    const e3 = Math.random().toString(36).slice(2, 8), t2 = document.createComment(`start:${e3}`), n3 = document.createComment(`end:${e3}`), r2 = document.createDocumentFragment();
    return r2.appendChild(t2), r2.appendChild(n3), { fragment: r2, startNode: t2, endNode: n3 };
  };
  if ("function" == typeof e2) {
    const { fragment: r2, startNode: o2, endNode: s2 } = n2();
    let a2 = null, c2 = null;
    return i(() => {
      try {
        let n3 = (e2[t], e2());
        if (null != n3 && false !== n3 && true !== n3 || (n3 = null), n3 === c2) return;
        if (a2) {
          if (a2.nodeType === Node.TEXT_NODE && ("string" == typeof n3 || "number" == typeof n3)) {
            const e3 = String(n3);
            return a2.textContent !== e3 && (a2.textContent = e3), void (c2 = n3);
          }
          if (a2 instanceof Element && n3 instanceof Element && a2.tagName === n3.tagName) {
            const e3 = a2.attributes, t2 = n3.attributes;
            for (const t3 of e3) n3.hasAttribute(t3.name) || a2.removeAttribute(t3.name);
            for (const e4 of t2) a2.getAttribute(e4.name) !== e4.value && a2.setAttribute(e4.name, e4.value);
            if (a2.childNodes.length === n3.childNodes.length) {
              let e4 = false;
              for (let t3 = 0; t3 < a2.childNodes.length; t3++) {
                const r4 = a2.childNodes[t3], o3 = n3.childNodes[t3];
                if (r4.nodeType !== Node.TEXT_NODE || o3.nodeType !== Node.TEXT_NODE) {
                  e4 = true;
                  break;
                }
                r4.textContent !== o3.textContent && (r4.textContent = o3.textContent);
              }
              if (!e4) return void (c2 = n3);
            }
          }
        }
        const r3 = s2.parentNode, i2 = document.createDocumentFragment();
        if (null != n3) {
          const e3 = x(n3);
          e3 && i2.appendChild(e3);
        }
        if (o2.nextSibling !== s2) {
          let e3 = o2.nextSibling;
          const t2 = [];
          for (; e3 && e3 !== s2; ) t2.push(e3), e3 = e3.nextSibling;
          t2.forEach((e4) => e4.remove());
        }
        i2.firstChild ? (r3.insertBefore(i2, s2), a2 = o2.nextSibling) : a2 = null, c2 = n3;
      } catch (e3) {
        handleError(e3, "processChild", { value: result });
      }
    }), r2;
  }
  if (Array.isArray(e2)) {
    const { fragment: t2, startNode: r2, endNode: o2 } = n2();
    let s2 = [], a2 = /* @__PURE__ */ new Map();
    return i(() => {
      const t3 = e2.flat(1 / 0).filter(Boolean);
      if (0 === t3.length) {
        if (0 === s2.length) return;
        return E(r2.nextSibling, o2), s2 = [], void a2.clear();
      }
      if (1 === t3.length && 1 === s2.length) {
        if (t3[0] === s2[0]) return;
        const e3 = S(t3[0]);
        return e3 && (E(r2.nextSibling, o2), r2.parentNode.insertBefore(e3, o2)), void (s2 = t3);
      }
      const n3 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map(), c2 = document.createDocumentFragment();
      t3.forEach((e3, t4) => {
        const r3 = T(e3, t4);
        n3.set(r3, { item: e3, index: t4 });
      }), s2.forEach((e3, t4) => {
        const n4 = T(e3, t4);
        i2.set(n4, { item: e3, index: t4, node: a2.get(n4) });
      });
      let l2 = 0;
      n3.forEach(({ item: e3, index: t4 }, n4) => {
        const r3 = i2.get(n4);
        if (r3) {
          const e4 = r3.node;
          e4 && (c2.appendChild(e4), a2.set(n4, e4), r3.index < l2 ? function(e5) {
            e5.dataset.reordered = "true";
          }(e4) : l2 = r3.index);
        } else {
          const t5 = S(e3);
          t5 && (c2.appendChild(t5), a2.set(n4, t5));
        }
      }), E(r2.nextSibling, o2), r2.parentNode.insertBefore(c2, o2), s2 = t3;
    }, [e2]), t2;
  }
  return e2 instanceof Node ? e2 : document.createTextNode(String(e2));
};
var x = (e2) => {
  if (Array.isArray(e2)) {
    const t2 = document.createDocumentFragment();
    return e2.forEach((e3) => {
      const n2 = S(e3);
      n2 && t2.appendChild(n2);
    }), t2;
  }
  return e2 instanceof Node ? e2 : document.createTextNode(String(e2));
};
function T(e2, t2) {
  return (e2 == null ? void 0 : e2.key) || `${typeof e2}:${String(e2)}:${t2}`;
}
function E(e2, t2) {
  const n2 = [];
  let r2 = e2;
  for (; r2 && r2 !== t2; ) n2.push(r2), r2 = r2.nextSibling;
  n2.forEach((e3) => e3.remove());
}
export {
  y as ErrorBoundary,
  u as Fragment,
  olova_default as default,
  l as h,
  b as lazy,
  s as onCleanup,
  d as render,
  m as setContext,
  i as setEffect,
  a as setMemo,
  w as setRef,
  c as setResource,
  o as setSignal,
  g as useContext
};
//# sourceMappingURL=olova.js.map
